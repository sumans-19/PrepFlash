
export interface InterviewParams {
  userId: string;
  userName: string;
  jobRole?: string;
  industry?: string;
  experienceLevel?: string;
  questionCount?: number;
  techStack?: string[];
}

export interface GenerateQuestionsResponse {
  questions: string[];
  interviewId: string;
}

export interface AnswerFeedback {
  clarity: number; // 1-10
  relevance: number; // 1-10
  completeness: number; // 1-10
  fillerWordsCount: number;
  fillerWords: string[];
  confidenceLevel: number; // 1-10
  suggestions: string[];
  overallScore: number; // 1-10
  responseTime?: number; // in seconds (optional)
  responseTimeScore?: number; // 1-10 (optional)
}

// Mock implementation for development and testing
// In a real application, this would connect to Gemini API
export const geminiGenerateQuestions = async (
  params: InterviewParams
): Promise<GenerateQuestionsResponse> => {
  console.log('Generating interview questions with params:', params);
  
  // For demonstration purposes, create a set of generic questions
  // that would normally be generated by Gemini
  const mockQuestions = [
    "Tell me about your experience with React and how you've used it in previous projects.",
    "How do you approach debugging complex issues in a web application?",
    "Describe a challenging technical problem you solved recently. What was your approach?",
    "How do you stay updated with the latest web technologies and programming practices?",
    "What experience do you have with state management in frontend applications?",
  ];

  // Create job-specific questions based on provided parameters
  let questions = [];
  
  if (params.jobRole?.toLowerCase().includes('frontend')) {
    questions = [
      `What are your favorite frontend frameworks, and why do you prefer them?`,
      `How do you optimize website performance for better user experience?`,
      `Explain your approach to responsive design and mobile-first development.`,
      `How do you handle cross-browser compatibility issues?`,
      `What frontend testing methodologies do you use in your projects?`
    ];
  } else if (params.jobRole?.toLowerCase().includes('backend')) {
    questions = [
      `Describe your experience with database design and optimization.`,
      `How do you ensure the security of an API you develop?`,
      `Explain your approach to handling scalability challenges in backend systems.`,
      `What's your experience with containerization and microservices?`,
      `How do you implement error handling in your backend applications?`
    ];
  } else if (params.jobRole?.toLowerCase().includes('full')) {
    questions = [
      `How do you manage the integration between frontend and backend components?`,
      `Describe your experience with full-stack development frameworks.`,
      `What's your approach to solving performance issues that span both frontend and backend?`,
      `How do you handle authentication and authorization in your applications?`,
      `Explain how you'd structure a full-stack project from scratch.`
    ];
  } else {
    // Default to generic technical questions if role is not specified
    questions = mockQuestions;
  }
  
  // Add tech stack specific questions if available
  if (params.techStack && params.techStack.length > 0) {
    const techStackLower = params.techStack.map(tech => tech.toLowerCase());
    
    if (techStackLower.some(tech => tech.includes('react'))) {
      questions.push(`Explain React hooks and how you use them in your projects.`);
    }
    
    if (techStackLower.some(tech => tech.includes('node'))) {
      questions.push(`What's your experience with Node.js and Express? How do you structure your applications?`);
    }
    
    if (techStackLower.some(tech => tech.includes('typescript'))) {
      questions.push(`How has TypeScript improved your development process? Give specific examples.`);
    }
  }
  
  // Limit to requested number of questions
  questions = questions.slice(0, params.questionCount || 5);

  // Simulate API delay
  await new Promise(resolve => setTimeout(resolve, 1500));
  
  return {
    questions,
    interviewId: `mock-${Math.random().toString(36).substring(2, 9)}`
  };
};

// Mock implementation for answer analysis
export const analyzeAnswer = async (
  question: string, 
  answer: string, 
  jobRole: string, 
  experienceLevel: string, 
  responseTime?: number, 
  fillerWords?: string[], 
  hesitations?: number
): Promise<AnswerFeedback> => {
  console.log(`Analyzing answer for question: "${question.substring(0, 30)}..."`);
  console.log(`Answer (${answer.length} chars): "${answer.substring(0, 50)}..."`);
  
  // Wait a bit to simulate API processing
  await new Promise(resolve => setTimeout(resolve, 2000));
  
  // Basic analysis based on answer length, filler words, and response time
  const answerLength = answer.length;
  
  // Simulate clarity score based on answer length and filler words
  let clarity = Math.min(9, Math.max(3, Math.floor(answerLength / 50)));
  if (fillerWords && fillerWords.length > 3) {
    clarity = Math.max(2, clarity - Math.floor(fillerWords.length / 2));
  }
  
  // Simulate relevance by checking if answer contains keywords from question
  const questionKeywords = question.toLowerCase()
    .replace(/[.,?!;:]/g, '')
    .split(' ')
    .filter(word => word.length > 4);
  
  const answerLower = answer.toLowerCase();
  const keywordMatches = questionKeywords.filter(keyword => 
    answerLower.includes(keyword)
  ).length;
  
  const relevance = Math.min(9, Math.max(3, 
    Math.floor((keywordMatches / Math.max(1, questionKeywords.length)) * 10)
  ));
  
  // Completeness based on answer length relative to question
  const completeness = Math.min(9, Math.max(3, 
    Math.floor(answerLength / (question.length * 0.7))
  ));
  
  // Confidence based on hesitations and filler words
  let confidenceLevel = 7; // Default somewhat confident
  if (hesitations && hesitations > 3) {
    confidenceLevel = Math.max(2, confidenceLevel - Math.floor(hesitations / 2));
  }
  if (fillerWords && fillerWords.length > 0) {
    confidenceLevel = Math.max(2, confidenceLevel - Math.min(3, fillerWords.length));
  }
  
  // Response time score - penalize if too quick or too slow
  let responseTimeScore;
  if (responseTime !== undefined) {
    if (responseTime < 2) {
      // Too quick, might not have thought through
      responseTimeScore = 5;
    } else if (responseTime > 60) {
      // Too slow
      responseTimeScore = 4;
    } else if (responseTime > 30) {
      // Somewhat slow
      responseTimeScore = 6;
    } else if (responseTime >= 2 && responseTime <= 10) {
      // Good response time
      responseTimeScore = 8;
    } else {
      // Acceptable
      responseTimeScore = 7;
    }
  }
  
  // Generate improvement suggestions
  const suggestions = [];
  
  if (clarity < 6) {
    suggestions.push("Try to articulate your thoughts more clearly with concrete examples.");
  }
  
  if (relevance < 6) {
    suggestions.push("Make sure your answer directly addresses the question asked.");
  }
  
  if (completeness < 6) {
    suggestions.push("Your answer could be more comprehensive. Consider covering more aspects of the question.");
  }
  
  if (confidenceLevel < 6) {
    suggestions.push("Work on speaking with more confidence by reducing hesitations and filler words.");
  }
  
  if (responseTimeScore !== undefined && responseTimeScore < 6) {
    if (responseTime! < 3) {
      suggestions.push("Take a moment to think before answering to provide a more thoughtful response.");
    } else {
      suggestions.push("Try to respond a bit more promptly while maintaining quality in your answer.");
    }
  }
  
  // Add a generic suggestion if we don't have enough specific ones
  if (suggestions.length < 2) {
    suggestions.push("Consider using more industry-specific terminology to demonstrate expertise.");
  }
  
  // Calculate overall score as weighted average of individual metrics
  const weights = {
    clarity: 0.2,
    relevance: 0.3,
    completeness: 0.2,
    confidenceLevel: 0.2,
    responseTimeScore: responseTimeScore !== undefined ? 0.1 : 0
  };
  
  const scores = {
    clarity,
    relevance,
    completeness,
    confidenceLevel,
    responseTimeScore: responseTimeScore || 0
  };
  
  const weightSum = Object.values(weights).reduce((sum, weight) => sum + weight, 0);
  
  const overallScore = Math.round(
    Object.entries(weights).reduce((score, [metric, weight]) => {
      return score + (scores[metric as keyof typeof scores] * weight);
    }, 0) / weightSum
  );
  
  return {
    clarity,
    relevance,
    completeness,
    fillerWordsCount: fillerWords?.length || 0,
    fillerWords: fillerWords || [],
    confidenceLevel,
    suggestions,
    overallScore,
    responseTime,
    responseTimeScore
  };
};

// Mock implementation to save answer feedback
export const saveAnswerFeedback = async (
  interviewId: string,
  userId: string,
  questionIndex: number,
  question: string,
  answer: string,
  feedback: AnswerFeedback
): Promise<void> => {
  console.log(`Saving feedback for question ${questionIndex + 1}`);
  console.log('Feedback data:', { interviewId, userId, questionIndex, feedback });
  
  // In a real app, this would save to Firebase
  await new Promise(resolve => setTimeout(resolve, 500));
  
  console.log('Answer feedback saved successfully');
};